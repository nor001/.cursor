---
description: 
globs: 
alwaysApply: false
---
# AHK v2 DEVELOPMENT STANDARDS

## ðŸŽ¯ AHK v2 Legacy Code Patterns

### **Legacy Code Preservation Rules**
- **ALWAYS preserve business logic** in legacy functions
- **NEVER refactor complex legacy methods** without extensive testing
- **ALWAYS document special cases** before making changes
- **Preserve variable naming conventions** for compatibility

### **Legacy Variable Standards**
```autohotkey
; STANDARD PATTERN for legacy variables
; ALWAYS preserve these prefixes for compatibility:
; - zcmt_* : SAP-specific variables (zcmt_ticket, zcmt_user)
; - lcl_*  : Legacy class names (lcl_sap_qas, lcl_memory)
; - i_*    : Input parameters (i_var, i_noexit)
; - l_*    : Local variables (l_var, l_name)
; - lt_*   : Local tables/arrays (lt_name, lt_code)
; - gt_*   : Global tables/arrays (gt_appclose, gt_snipaste)

; ALWAYS validate legacy variable format
function validateLegacyVariable(legacyVar: string): boolean {
  // Preserve special prefixes
  if (InStr(legacyVar, "zcmt_") || InStr(legacyVar, "lcl_")) {
    return true; // SAP and legacy class variables
  }
  
  // Validate input/output patterns
  if (InStr(legacyVar, "i_") || InStr(legacyVar, "l_") || InStr(legacyVar, "lt_")) {
    return true; // Legacy parameter patterns
  }
  
  return false;
}
```

### **AHK v2 Class Standards**
```autohotkey
; STANDARD PATTERN for AHK v2 classes
class ModernAHKClass {
  __new() {
    ; ALWAYS initialize properties
    this.properties := {}
    this.state := "initialized"
  }
  
  ; ALWAYS use descriptive method names
  performSpecificAction(parameter: string): boolean {
    ; Implementation with clear logic
    return true
  }
  
  ; ALWAYS include error handling
  riskyOperation() {
    try {
      result := this.performSpecificAction("test")
      return { success: true, data: result }
    } catch Error as e {
      ; ALWAYS log errors for debugging
      console.error("Operation failed:", e.message)
      return { success: false, error: e.message }
    }
  }
}
```

### **Legacy Method Refactoring Standards**
```autohotkey
; BEFORE refactoring legacy code:
; 1. Document current behavior completely
; 2. Create comprehensive tests for all scenarios
; 3. Identify all special cases and edge conditions
; 4. Preserve backward compatibility at all costs

; DURING refactoring:
; 1. Make incremental changes only
; 2. Test each change thoroughly
; 3. Preserve all business logic exactly
; 4. Maintain performance characteristics

; AFTER refactoring:
; 1. Verify all functionality works as before
; 2. Test edge cases and special scenarios
; 3. Update documentation with new patterns
; 4. Monitor for regressions in production
```

### **SAP Legacy Integration Patterns**
```autohotkey
; SAP Legacy Code Preservation
; ALWAYS preserve SAP-specific business logic
; NEVER modify SAP connection patterns without testing
; ALWAYS maintain SAP environment compatibility
; Document SAP-specific special cases

; STANDARD PATTERN for SAP legacy variables
interface SAPLegacyConfig {
  ; SAP-specific legacy variables
  zcmt_ticket: string
  zcmt_user: string
  zcmt_logon1: string
  zcmt_logon2: string
  zcmt_logon3: string
  ; Environment-specific variables
  l_mandt: string
  l_user: string
  l_pass: string
  l_conexionname: string
}

; STANDARD PATTERN for SAP legacy methods
class SAPLegacyManager {
  ; ALWAYS preserve complex SAP logic
  logon(legacyInput: string): boolean {
    ; 1. Validate legacy input format
    if (!this.isValidLegacyInput(legacyInput)) {
      throw new SAPLegacyError("Invalid legacy input format")
    }
    
    ; 2. Preserve existing business logic
    parsedInput := this.parseLegacyInput(legacyInput)
    
    ; 3. Maintain SAP environment compatibility
    return this.executeSAPLogon(parsedInput)
  }
}
```

### **AHK v2 Error Handling Standards**
```autohotkey
; STANDARD PATTERN for AHK v2 error handling
try {
  result := riskyOperation()
  return { success: true, data: result }
} catch Error as e {
  ; ALWAYS log errors for debugging
  console.error("Operation failed:", e.message)
  return { success: false, error: e.message }
}

; ALWAYS handle errors gracefully
function safeOperation() {
  try {
    return performOperation()
  } catch Error as e {
    ; Log for debugging but don't expose internals
    console.error("Operation failed:", e)
    return { 
      success: false, 
      error: "Operation failed. Please try again." 
    }
  }
}
```

### **Legacy Code Documentation Standards**
```autohotkey
; ALWAYS document complex legacy logic
/**
 * Special SAP logon processing for legacy format
 * Handles multiple environment types (dev, qas, prd)
 * Required for corporate SAP integration
 */
function processSAPLogon(legacyInput: string): boolean {
  ; Implementation with clear comments
}

; ALWAYS document special cases
; SPECIAL CASE: CSV headers on line 3 for SAP format
; SPECIAL CASE: Corporate VPN requirements for SAP access
; SPECIAL CASE: Legacy variable prefixes for compatibility
```

### **Performance and Memory Management**
```autohotkey
; ALWAYS optimize for AHK v2 performance
; Use SetWorkingDir() for file operations
; Use FileEncoding("UTF-8") for international support
; Use SetTitleMatchMode(2) for flexible window matching
; Use SendMode("Input") for reliable input simulation

; STANDARD PATTERN for performance optimization
class OptimizedAHKClass {
  __new() {
    ; Initialize performance settings
    SetWorkingDir(A_ScriptDir)
    FileEncoding("UTF-8")
    SetTitleMatchMode(2)
    SendMode("Input")
  }
  
  ; ALWAYS clean up resources
  __delete() {
    ; Clean up any allocated resources
  }
}
```

### **Testing and Validation Standards**
```autohotkey
; ALWAYS test legacy functionality before changes
; Create comprehensive test scenarios
; Test edge cases and special conditions
; Validate backward compatibility

; STANDARD PATTERN for legacy testing
function testLegacyFunctionality() {
  ; Test normal operation
  result1 := legacyFunction("normal_input")
  if (!result1.success) {
    throw new TestError("Normal operation failed")
  }
  
  ; Test edge cases
  result2 := legacyFunction("edge_case_input")
  if (!result2.success) {
    throw new TestError("Edge case failed")
  }
  
  ; Test special cases
  result3 := legacyFunction("special_case_input")
  if (!result3.success) {
    throw new TestError("Special case failed")
  }
  
  return true
}
```

### **Migration and Compatibility**
```autohotkey
; ALWAYS maintain backward compatibility
; Preserve existing function signatures
; Maintain variable naming conventions
; Keep existing business logic intact

; STANDARD PATTERN for safe migration
class MigrationHelper {
  ; ALWAYS provide migration path
  migrateLegacyFunction(oldFunction: string, newFunction: string) {
    ; 1. Create wrapper for old function
    ; 2. Implement new function with improvements
    ; 3. Test both functions work identically
    ; 4. Gradually migrate callers to new function
  }
  
  ; ALWAYS validate migration
  validateMigration(oldResult: any, newResult: any): boolean {
    return oldResult == newResult
  }
}
```

---

## ðŸš¨ CRITICAL: Legacy Code Preservation

### **NEVER Remove Special Logic**
- **NEVER remove special parsing logic** (like SAP format handling)
- **NEVER simplify complex business rules** without explicit confirmation
- **ALWAYS ask before removing** any "special case" handling
- **Document special cases** in code comments for future reference

### **ALWAYS Preserve Business Logic**
- **Preserve SAP-specific logic** exactly as implemented
- **Maintain corporate environment compatibility**
- **Keep legacy variable naming conventions**
- **Preserve performance characteristics**

### **Safe Refactoring Guidelines**
- **Incremental changes only** - never big-bang refactoring
- **Comprehensive testing** before and after changes
- **Documentation updates** for all changes
- **Backward compatibility** at all costs
